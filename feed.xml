<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://shchur.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://shchur.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-09-22T10:21:53+00:00</updated><id>https://shchur.github.io/feed.xml</id><title type="html">blank</title><subtitle>A blog about machine learning, probabilistic models and temporal point processes. </subtitle><entry><title type="html">Temporal Point Processes 2: Neural TPP Models</title><link href="https://shchur.github.io/blog/2021/tpp2-neural-tpps/" rel="alternate" type="text/html" title="Temporal Point Processes 2: Neural TPP Models"/><published>2021-06-28T00:00:00+00:00</published><updated>2021-06-28T00:00:00+00:00</updated><id>https://shchur.github.io/blog/2021/tpp2-neural-tpps</id><content type="html" xml:base="https://shchur.github.io/blog/2021/tpp2-neural-tpps/"><![CDATA[<d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#representing-the-data">Representing the data</a></div> <div><a href="#constructing-a-neural-tpp-model">Constructing a neural TPP model</a></div> <ul> <li><a href="#encoding-the-history-into-a-vector">Encoding the history into a vector</a></li> <li><a href="#choosing-a-parametric-distribution">Choosing a parametric distribution</a></li> <li><a href="#conditional-distribution">Conditional distribution</a></li> </ul> <div><a href="#likelihood-function">Likelihood function</a></div> <div><a href="#putting-everything-together">Putting everything together</a></div> <div><a href="#concluding-remarks">Concluding remarks</a></div> </nav> </d-contents> <p>In this post, we will learn about <a href="https://arxiv.org/abs/2104.03528">neural temporal point processes</a> (TPPs) — flexible generative models for variable-length event sequences in continuous time. More specifically, we will</p> <ul> <li>Learn how to parametrize TPPs using neural networks;</li> <li>Derive the likelihood function for TPPs (that we will use as the training objective for our model);</li> <li>Implement a neural TPP model in PyTorch.</li> </ul> <p>If you haven’t read the <a href="https://shchur.github.io/2020/12/17/tpp1-conditional-intensity.html">previous post in the series</a>, I recommend checking it out to get familiar with the main concepts and notation. Alternatively, click on the arrow below to see a short recap of the basics.</p> <details> <summary>Recap</summary> A temporal point process (TPP) is a probability distribution over variable-length event sequnces in a time interval $[0, T]$. We can represent a realization of a TPP as a sequence of <i>strcitly increasing</i> arrival times $\boldsymbol{t} = (t_1, ..., t_N)$, where $N$, the number of events, is itself a random variable. We can specify a TPP by defining $P_i^*(t_i)$, the conditional distribution of the next arrival time $t_i$ given past events $\{t_1, \dots, t_{i-1}\}$, for $i = 1, 2, 3, \dots$. The distribution $P_i^*(t_i)$ can be specified with either a <a target="_blank" href="https://en.wikipedia.org/wiki/Probability_density_function">probability density function</a> (PDF) $f_i^*$, a <a target="_blank" href="https://en.wikipedia.org/wiki/Survival_function">survival function</a> (SF) $S_i^*$, or a <a target="_blank" href="https://en.wikipedia.org/wiki/Failure_rate">hazard function</a> (HF) $h_i^*$. </details> <h2 id="representing-the-data">Representing the data</h2> <p>We will define our neural TPP as an autoregressive model. To do this, at each step $i = 1, 2, 3, …$ we need to specify the distribution \(P_i^*(t_i) := P_i(t_i \vert \mathcal{H}_{t_i})\) of the next arrival time \(t_i\) given the history of past events \(\mathcal{H}_{t_i} = \{t_1, \dots, t_{i-1}\}\). An equivalent but more convenient approach is to instead work with the <em>inter-event</em> times $(\tau_1, \dots, \tau_{N+1})$,<d-footnote>Note that we represent an event sequence $(t_1, \dots, t_N)$ with $N$ events using $N+1$ inter-event times. The last inter-event time $\tau_{N+1}$ corresponds to the time from the last event until $T$, the end of the observed time interval.</d-footnote> where we compute $\tau_i = t_i - t_{i-1}$ (assuming $t_0 = 0$ and $t_{N+1} = T$).</p> <div class="l-body"> <img class="img-fluid rounded" src="/assets/img/posts/tpp2/inter_times.png" style="display: block; width: 80%; margin-left: auto; margin-right: auto;"/> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> An event sequence can equivalently be represented by the arrival times $(t_1, \dots, t_N)$ or the inter-event times $(\tau_1, \dots, \tau_{N+1})$. </figcaption> </div> <p>First, let’s load some data and covnert it into a format that can be processed by our model. You can find the dataset and a <a href="https://colab.research.google.com/github/shchur/shchur.github.io/blob/gh-pages/assets/notebooks/tpp2/neural_tpp.ipynb">Jupyter notebook</a> with all the code used in this blog post <a href="https://github.com/shchur/shchur.github.io/blob/gh-pages/assets/notebooks/tpp2/">here</a>.</p> <d-code language="python"> import numpy as np import torch from torch.nn.utils.rnn import pad_sequence data = torch.load("toy_dataset.pkl") # arrival_times_list is a list of variable-length lists # arrival_times_list[j] is the list of arrival times of sequence j arrival_times_list = data["arrival_times"] # t_end = length of the observerd time interval [0, t_end] t_end = data["t_end"] seq_lengths = torch.tensor( [len(t) for t in arrival_times_list], dtype=torch.long ) # (B,) def get_inter_times(t, t_end): tau = np.diff(t, prepend=0.0, append=t_end) return torch.tensor(tau, dtype=torch.float32) inter_times_list = [get_inter_times(t, t_end) for t in arrival_times_list] inter_times = pad_sequence(inter_times_list, batch_first=True) # (B, L) </d-code> <div class="l-body"> <img class="img-fluid rounded" src="/assets/img/posts/tpp2/preprocess_times.png" style="display: block; width: 90%; margin-left: auto; margin-right: auto;"/> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> We convert 3 variable-length event sequences of arrival times $\boldsymbol{t}^{(1)}$, $\boldsymbol{t}^{(2)}$, $\boldsymbol{t}^{(3)}$ into a tensor of padded inter-event times of shape <tt>(B, L)</tt>, where <tt>B</tt> - batch size, <tt>L</tt> - padded length. </figcaption> </div> <h2 id="constructing-a-neural-tpp-model">Constructing a neural TPP model</h2> <p>How can we parametrize the conditional distribution \(P_i^*(\tau_i)\) with a neural network? A simple and elegant answer to this question was proposed in the seminal work by Du, Dai, Trivedi, Gomez-Rodriguez and Song <d-cite key="du2016recurrent"></d-cite>:</p> <ol> <li>Encode the event history \(\mathcal{H}_{t_i} = \{t_1, \dots, t_{i-1}\}\) into a <em>fixed-dimensional</em> context vector \(\boldsymbol{c}_i \in \mathbb{R}^C\) using a neural network.</li> <li>Pick a parametric probability density function \(f(\cdot \vert \boldsymbol{\theta})\) that defines the distribution of a positive<d-footnote>We always assume that the arrival times are sorted, that is, $t_i &lt; t_{i+1}$ for all $i$. Therefore, the inter-event times $\tau_i$ are strictly positive.</d-footnote> random variable (e.g., PDF of the <a href="https://en.wikipedia.org/wiki/Exponential_distribution">exponential distribution</a> or <a href="https://en.wikipedia.org/wiki/Weibull_distribution">Weibull distribution</a>).</li> <li>Use the context vector \(\boldsymbol{c}_i\) to obtain the parameters \(\boldsymbol{\theta}_i\). Plug in \(\boldsymbol{\theta}_i\) into \(f(\cdot \vert \boldsymbol{\theta})\) to obtain the PDF \(f(\tau_i \vert \boldsymbol{\theta}_i)\) of the conditional distribution \(P_i^*(\tau_i)\).</li> </ol> <p>We will now look at each of these steps in more detail.</p> <div class="l-body"> <img class="img-fluid rounded" src="/assets/img/posts/tpp2/architecture.png" style="display: block; width: 90%; margin-left: auto; margin-right: auto;"/> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> Schematic representation of the neural TPP model that we will implement today. </figcaption> </div> <h3 id="encoding-the-history-into-a-vector">Encoding the history into a vector</h3> <p>The original approach by Du et al. <d-cite key="du2016recurrent"></d-cite> uses a recurrent neural network (RNN) to encode the event history into a vector. This works as follows.</p> <ol type="i"> <li>Each event $t_j$ is represented by a feature vector $\boldsymbol{y}_j$. In our model, we will simply define $\boldsymbol{y}_j = (\tau_j, \log \tau_j)^T$.<d-footnote>Using the logarithm here allows the model to distinguish between very small inter-event times.</d-footnote> More sophisticated approaches, like positional encoding with trigonometric functions <d-cite key="zhang2020self"></d-cite>, are also possible.</li> <li>We initialize $\boldsymbol{c}_1$ (for example, to a vector of all zeros). The vector $\boldsymbol{c}_1$ will work both as the initial state of the RNN, as well as to obtain the parameters of $P_1^*(\tau_1)$.</li> <li>After each event $t_i$, we compute the next the context vector $\boldsymbol{c}_{i+1}$ (i.e., the next hidden state of the RNN) based on the previous state $\boldsymbol{c}_i$ and features $\boldsymbol{y}_i$ $$ \boldsymbol{c}_{i+1} = \operatorname{Update}(\boldsymbol{c}_i, \boldsymbol{y}_{i}). $$ The specific RNN architecture is not very important here &#8212; <a target="_blank" href="https://pytorch.org/docs/stable/generated/torch.nn.RNN.html">vanilla RNN</a>, <a target="_blank" href="https://pytorch.org/docs/stable/generated/torch.nn.GRU.html">GRU</a> or <a target="_blank" href="https://pytorch.org/docs/stable/generated/torch.nn.LSTM.html">LSTM</a> update functions can all be used here. By processing the entire sequence $(t_1, \dots, t_N)$, we compute all the context vectors $(\boldsymbol{c}_1, \dots, \boldsymbol{c}_{N+1})$. </li> </ol> <d-code language="python"> import torch.nn as nn import torch.nn.functional as F context_size = 32 rnn = nn.GRU(input_size=2, hidden_size=context_size, batch_first=True) def get_context(inter_times): # inter_times: Padded inter-event times, shape (B, L) tau = inter_times.unsqueeze(-1) # (B, L, 1) # Clamp tau to avoid computing log(0) for padding and getting NaNs log_tau = inter_times.clamp_min(1e-8).log().unsqueeze(-1) # (B, L, 1) rnn_input = torch.cat([tau, log_tau], dim=-1) # (B, L, 2) # The intial state is automatically set to zeros rnn_output = rnn(rnn_input) # (B, L, C) # Shift by one such that context[:, i] will be used # to parametrize the distribution of inter_times[:, i] context = F.pad(rnn_output[:, :-1, :], (0, 0, 1, 0)) # (B, L, C) return context </d-code> <div class="l-body"> <img class="img-fluid rounded" src="/assets/img/posts/tpp2/padding.png" style="display: block; width: 90%; margin-left: auto; margin-right: auto;"/> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> We shift the <tt>rnn_output</tt> by one and add padding to obtain the <tt>context</tt> tensor that is properly aligned with the <tt>inter_times</tt>. </figcaption> </div> <h3 id="choosing-a-parametric-distribution">Choosing a parametric distribution</h3> <p>When picking a parametric distribution for inter-event times, we have to make sure that its probability density function (PDF) $f(\cdot \vert \boldsymbol{\theta})$ and survival function $S(\cdot \vert \boldsymbol{\theta})$ can be computed analytically — we will need this later when computing the log-likelihood. For some applications, it’s also nice to able to sample from the distribution analytically. I decided to use <a target="_blank" href="https://en.wikipedia.org/wiki/Weibull_distribution#Alternative_parameterizations">Weibull distribution</a> here as it satisfies all these properties.<d-footnote>Many other distributions over $[0, \infty)$ also satisfy these properties (e.g., exponential, log-normal, log-logistic, Gompertz distributions, or their mixtures), but some don't. For example, computing the survival function and sampling are not straightforward for the gamma distribution.</d-footnote></p> <div class="l-body"> <img class="img-fluid rounded" src="/assets/img/posts/tpp2/weibull.png" style="display: block; width: 100%; margin-left: auto; margin-right: auto;"/> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> PDF of the Weibull distribution with different values of the parameters $b$ and $k$. </figcaption> </div> <p>The Weibull distribution has two strictly positive parameters $\boldsymbol{\theta} = (b, k)$. The probability density function is computed as \[ f(\tau \vert b, k) = b k \tau^{k-1} \exp(-b \tau^{k}) \] and the survival function is \[ S(\tau \vert b, k) = \exp(-b \tau^{k}). \]</p> <p>We implement the Weibull distribution using an API that is similar to <tt><a href="https://pytorch.org/docs/stable/distributions.html">torch.distributions</a></tt>.</p> <d-code language="python"> class Weibull: def __init__(self, b, k, eps=1e-8): # b and k are strictly positive tensors of the same shape self.b = b self.k = k self.eps = eps def log_prob(self, x): """Logarithm of the probability density function log(f(x)).""" # x must have the same shape as self.b and self.k x = x.clamp_min(self.eps) # pow is unstable for inputs close to 0 return (self.b.log() + self.k.log() + (self.k - 1) * x.log() + self.b.neg() * torch.pow(x, self.k)) def log_survival(self, x): """Logarithm of the survival function log(S(x)).""" x = x.clamp_min(self.eps) return self.b.neg() * torch.pow(x, self.k) </d-code> <h3 id="conditional-distribution">Conditional distribution</h3> <p>To obtain the conditional PDF $f^*_i(\tau_i) := f(\tau_i | k_i, b_i)$ of the next inter-event time given the history, we compute the parameters $k_i$, $b_i$ using the most recent context embedding $\boldsymbol{c}_i$ \[ \begin{aligned} k_i = \sigma(\boldsymbol{v}^T_k \boldsymbol{c}_i + d_k) &amp; \qquad &amp; b_i = \sigma(\boldsymbol{v}^T_b \boldsymbol{c}_i + d_b). \end{aligned} \] Here, $\boldsymbol{v}_k \in \mathbb{R}^C, \boldsymbol{v}_b \in \mathbb{R}^C, d_k \in \mathbb{R}, d_b \in \mathbb{R}$ are learnable weights, and $\sigma: \mathbb{R} \to (0, \infty)$ is a nonlinear function that ensures that the parameters are strictly positive (e.g., softplus).</p> <d-code language="python"> hypernet = nn.Linear(in_features=context_size, out_features=2) def get_inter_time_distribution(context): # context has shape (B, L, C) raw_params = hypernet(context) # (B, L, 2) b = F.softplus(raw_params[..., 0]) # (B, L) k = F.softplus(raw_params[..., 1]) # (B, L) return Weibull(b, k) </d-code> <p>The weights $\{\boldsymbol{v}_k, \boldsymbol{v}_b, d_k, d_b\}$ together with the weights of the RNN are the learnable parameters of our neural TPP model. The next question we have to answer is how to estimate these from data.</p> <h2 id="likelihood-function">Likelihood function</h2> <p>Log-likelihood (LL) is the default training objective for generative probabilistic models, and TPPs are no exception. To derive the likelihood function for a TPP we will start with a simple example.</p> <p>Suppose we have observed a single event with arrival time \(t_1\) in the time interval \([0, T]\). We can describe this outcome as “the first event happened in $[t_1, t_1 + dt)$ and the second event happened after $T$”. <d-footnote>Here $dt$ denotes an infinitesimal positive number.</d-footnote> The probability of this outcome is</p> \[\begin{align} \begin{split} p(\{t_1\}) =&amp; \Pr(\text{1st event in $[t_1, t_1 + dt)$})\\ &amp; \times \Pr(\text{2nd event after $T$} \mid t_1)\\ =&amp; f_1^*(t_1) dt \times S_2^*(T) \end{split} \end{align}\] <p>The equality here follows simply from the definition of the PDF \(f_1^*\) and the survival function \(S_2^*\) (as discussed in the <a href="https://shchur.github.io/blog/2020/tpp1-conditional-intensity/">previous post</a>).<d-footnote>We can make another interesting observation here. When computing the probability in Equation (1), we could also consider the event $$ \{\text{3rd event after $T$} \mid \text{1st event at $t_1$, 2nd event after $T$} \}. $$ However, the probability of this event is equal to 1, since we already know that the second event happened after $T$ and, by definition, the third event happens after the second event. The same holds for events like $\{\text{4th event after $T$} \mid ... \}$. Therefore, even though a TPP realization may contain an arbitrary large number of events, when computing the the likelihood of a particular sequence $\boldsymbol{t} = (t_1, \dots, t_N)$, we only need to consider $N+1$ terms.</d-footnote> Following the same reasoning, we compute the likelihood for an arbitrary sequence \(\boldsymbol{t} = (t_1, t_2, \dots, t_N)\) consisting of \(N\) events as</p> \[\begin{align} p(\boldsymbol{t}) = (dt)^N \left(\prod_{i=1}^{N} f_i^*(t_i)\right) S_{N+1}^*(T). \end{align}\] <p>The $(dt)^N$ term is just a multiplicative constant with respect to the model parameters, so we ignore it during optimization. By taking the logarithm, we get the log-likelihood</p> \[\begin{align} \log p(\boldsymbol{t}) &amp;= \left(\sum_{i=1}^{N} \log f_i^*(t_i)\right) + \log S_{N+1}^*(T). \end{align}\] <p>Lastly, by slightly abusing the notation, we switch back to the inter-event times and obtain</p> \[\begin{align} \log p(\boldsymbol{t}) &amp;= \left(\sum_{i=1}^{N} \log f_i^*(\tau_i)\right) + \log S_{N+1}^*(\tau_{N+1}). \end{align}\] <p>We will use this formulation of the log-likelihood to train our neural TPP model.</p> <p>It’s worth noting that Equation (4) is not the only way to express the log-likelihood of a TPP. In the previous post, we talked about different functions characterizing a TPP, such as conditional hazard functions \(\{h_1^*, h_2^*, h_3^*...\}\) and the conditional intensity function \(\lambda^*(t)\). Many papers and textbooks work with these functions instead. Click on the arrow below for more details.</p> <details> <summary>Other ways to compute the log-likelihood of a TPP</summary> We combine Equation (3) with the definition of the conditional hazard function $h_i^*(t) = f_i^*(t)/S_i^*(t)$ and obtain $$ \begin{aligned} \log p(\boldsymbol{t}) =&amp; \left(\sum_{i=1}^{N} \log f_i^*(t_i)\right) + \log S_{N+1}^*(T)\\ =&amp; \left(\sum_{i=1}^{N} \log h_i^*(t_i) + \log S_i^*(t_i)\right) + \log S_{N+1}^*(T)\\ =&amp; \sum_{i=1}^{N} \log h_i^*(t_i) + \sum_{i=1}^{N+1} \log S_i^*(t_i), \end{aligned} $$ where we defined $t_{N+1}=T$. Last time, we derived the equality <d-footnote> From the definition of the hazard function, it follows $$ \begin{aligned} h_i^*(t) &amp;= \frac{f_i^*(t)}{S_i^*(t)} = \frac{- \frac{d}{dt} S_i^*(t)}{S_i^*(t)} = -\frac{d}{dt} \log S_i^*(t)\\ &amp; \Leftrightarrow S_i^*(t) = \exp \left( -\int_{t_{i-1}}^t h_i^*(u) du \right) \end{aligned} $$</d-footnote> $$S_i^*(t) = \exp \left(-\int_{t_{i-1}}^{t} h_i^*(u) du\right).$$ Plugging this into the expression for the log-likelihood, we get $$ \begin{aligned} \log p(\boldsymbol{t}) =&amp; \sum_{i=1}^{N} \log h_i^*(t_i) - \sum_{i=1}^{N+1} \left(\int_{t_{i-1}}^{t_i} h_i^*(u) du\right) \end{aligned} $$ Finally, using the definition of the conditional intensity,<d-footnote> The conditional intensity is defined piecewise by stitching together the hazard functions $$ \lambda^*(t) = \begin{cases} h_1^*(t) &amp; \text{ if } 0 \le t \le t_1 \\ h_2^*(t) &amp; \text{ if } t_1 &lt; t \le t_2 \\ &amp; \vdots\\ h_{N+1}^*(t) &amp; \text{ if } t_N &lt; t \le T \\ \end{cases} $$ </d-footnote> we rewrite the log-likelihood as $$ \begin{aligned} \log p(\boldsymbol{t}) =&amp; \sum_{i=1}^{N} \log \lambda^*(t_i) - \sum_{i=1}^{N+1} \left(\int_{t_{i-1}}^{t_i} \lambda^*(u) du\right)\\ =&amp; \sum_{i=1}^{N} \log \lambda^*(t_i) - \int_{0}^{T} \lambda^*(u) du. \end{aligned} $$ You will often see this expression for the LL in papers and textbooks. As we have just showed, it is exactly equivalent to both Equations (3) and (4) that we derived before. </details> <p><br/></p> <p>The trickiest part when implementing TPP models is vectorizing the operations on variable-length sequences (i.e., avoiding for-loops). This is usually done with masking and operations like <tt>torch.gather</tt>. For example, here is a vectorized implementation of the negative log-likelihood (NLL) for our neural TPP model.</p> <d-code language="python"> def nll_loss(inter_times, seq_lengths): # inter_times: Padded inter-event times, shape (B, L) # seq_lengths: Number of events in each sequence, shape (B,) context = get_context(inter_times) # (B, L, C) inter_time_dist = get_inter_time_distribution(context) log_pdf = inter_time_dist.log_prob(inter_times) # (B, L) # Construct a boolean mask that selects observed events arange = torch.arange(inter_times.shape[1], device=seq_lengths.device) mask = (arange[None, :] &lt; seq_lengths[:, None]).float() # (B, L) log_like = (log_pdf * mask).sum(-1) # (B,) log_surv = inter_time_dist.log_survival(inter_times) # (B, L) end_idx = seq_lengths.unsqueeze(-1) # (B, 1) log_surv_last = torch.gather(log_surv, dim=-1, index=end_idx) # (B, 1) log_like += log_surv_last.squeeze(-1) # (B,) return -log_like </d-code> <div class="l-body"> <img class="img-fluid rounded" src="/assets/img/posts/tpp2/nll_computation.png" style="display: block; width: 90%; margin-left: auto; margin-right: auto;"/> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> Log-likelihood of a sequence $(\tau_1, ..., \tau_{N+1})$ is computed as $\left(\sum_{i=1}^{N} \log f^*_i(\tau_i)\right) + \log S_{N+1}^*(\tau_{N+1})$. In the above figure this corresponds to summing up the orange entries in each row. </figcaption> </div> <h2 id="putting-everything-together">Putting everything together</h2> <p>Now we have all the pieces necessary to define and train our model. Here is a link to the <a href="https://colab.research.google.com/github/shchur/shchur.github.io/blob/gh-pages/assets/notebooks/tpp2/neural_tpp.ipynb">Jupyter notebook</a> with all the code we’ve seen so far, but where the different model components are nicely wrapped into a single <tt>nn.Module</tt>.</p> <p>As mentioned before, we train the model by minimizing the NLL of the training sequences. More specifically, we average the loss over all sequences and normalize it by $T$, the length of the observed time interval.</p> <d-code language="python"> model = NeuralTPP() opt = torch.optim.Adam(model.parameters(), lr=5e-3) max_epochs = 200 for epoch in range(max_epochs): opt.zero_grad() loss = model.nll_loss(inter_times, seq_lengths).mean() / t_end loss.backward() opt.step() </d-code> <p>There are different ways to evaluate TPP models. Here, I chose to visualize some properties of the event sequences generated by the model and compare them to those of the training data. The code for sampling is not particularly interesting. It follows the same logic as before — at each step $i$, we sample the next inter-event time $\tau_i \sim f_i^*(\tau_i)$, feed it into the RNN to obtain the next context embedding $\boldsymbol{c}_{i+1}$, and repeat the procedure. See the <a href="https://colab.research.google.com/github/shchur/shchur.github.io/blob/gh-pages/assets/notebooks/tpp2/neural_tpp.ipynb">Jupyter notebook</a> for details.</p> <div class="l-body"> <img class="img-fluid rounded" src="/assets/img/posts/tpp2/visualize_results.png" style="display: block; width: 100%; margin-left: auto; margin-right: auto;"/> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> Comparison of real and generated event sequences. <br/> <b>Left:</b> Visualization of the arrival times in 10 real (top) and 10 simulated (bottom) sequences. <br/> <b>Right:</b> Distribution of sequence lengths for real (top) and simulated (bottom) event sequences. </figcaption> </div> <p>We see that training sequences have a trend: there are a lot more events in the $[0, 50]$ interval than in $[50, 100]$ (top left figure). Our neural TPP model has learned to produce sequences with a similar property (bottom left). The figure also shows that the distribution of the sequence lengths in real (top right) and simulated (bottom right) sequences are quite similar. We conclude that the model has approximated the true data-generating TPP reasonably well. Of course, there is room for improvement. After all, we defined a really simple architecture, and it’s possible to get even better results by using a more flexible model.</p> <h2 id="concluding-remarks">Concluding remarks</h2> <p>In this post, we have learned about the general design principles of neural TPPs and implemented a simple model of this class. Unlike traditional TPP models that we discussed in the previous post (Poisson processes, Hawkes processes), neural TPPs can simultaneously capture different patterns in the data (e.g., global trends, burstiness, repeating subsequences).</p> <p>Neural TPPs are a hot research topic, and a number of improvements have been proposed in the last couple of years. For example, one can use a transformer as the history encoder <d-cite key="zhang2020self,zuo2020transformer"></d-cite>, or choose a more flexible parametrization of the conditional distribution <d-cite key="omi2019fully,shchur2020intensity,zhang2020cause"></d-cite>. Some works take a completely different approach — they directly parametrize the conditional intenisity $\lambda^*(t)$ using a hidden state that evolves in continuous time according to a (neural) ODE <d-cite key="de2019gru,rubanova2019latent"></d-cite>, instead of defining the model autoregressively. If you want to learn more about neural TPPs, their applications, and open challenges, you can check our recent survey paper <d-cite key="shchur2021neural"></d-cite>.</p> <p>So far we have been talking exclusively about the so-called <em>unmarked</em> TPPs, where each event is represented only by its arrival time $t_i$. Next time, I will talk about the important case of <em>marked</em> TPPs, where events come with additional information, such as class labels or spatial locations.</p> <h3 id="acknowledgments">Acknowledgments</h3> <p>I would like to thank <a href="https://twitter.com/DanielZuegner">Daniel Zügner</a> for his feedback on this post.</p>]]></content><author><name>Oleksandr Shchur</name></author><summary type="html"><![CDATA[How can we define flexible TPP models using neural networks?]]></summary></entry><entry><title type="html">Temporal Point Processes 1: The Conditional Intensity Function</title><link href="https://shchur.github.io/blog/2020/tpp1-conditional-intensity/" rel="alternate" type="text/html" title="Temporal Point Processes 1: The Conditional Intensity Function"/><published>2020-12-17T00:00:00+00:00</published><updated>2020-12-17T00:00:00+00:00</updated><id>https://shchur.github.io/blog/2020/tpp1-conditional-intensity</id><content type="html" xml:base="https://shchur.github.io/blog/2020/tpp1-conditional-intensity/"><![CDATA[<d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#what-is-a-point-process"> What is a point process?</a></div> <div><a href="#tpp-as-an-autoregressive-model">TPP as an autoregressive model</a></div> <div><a href="#defining-tpps-using-the-conditional-intensity-function">Defining TPPs using the conditional intensity function</a></div> <div><a href="#tpp-as-a-counting-process">TPP as a counting process</a></div> <div><a href="#summary">Summary</a></div> </nav> </d-contents> <h2 id="tldr">TL;DR</h2> <ul> <li>Temporal point processes (TPPs) are probability distributions over variable-length event sequences in continuous time.</li> <li>We can view a TPP as an autoregressive model or as a counting process.</li> <li>The conditional intensity function $\lambda^*(t)$ connects these two viewpoints and allows us to specify TPPs with different behaviors, such as a global trend or burstiness.</li> <li>The conditional intensity $\lambda^*(t)$ is one of many ways to define a TPP — as an alternative, we could, for example, specify the conditional PDFs of the arrival times \(\{f_1^*, f_2^*, f_3^*, ...\}\).</li> </ul> <h2 id="what-is-a-point-process">What is a point process?</h2> <p>Probabilistic generative models are the bread and butter of modern machine learning. They allow us to make predictions, find anomalies and learn useful representations of the data. Most of the time, applying the generative model involves learning the probability distribution \(P(\boldsymbol{x})\) over our data points \(\boldsymbol{x}\).</p> <p>We know what to do if \(\boldsymbol{x}\) is a vector in \(\mathbb{R}^D\) — simply use a multivariate Gaussian or, if we need something more flexible, our favorite <a href="https://arxiv.org/abs/1912.02762">normalizing flow</a> model. But what if a single realization of our probabilistic model corresponds to a <em>set</em> of vectors \(\{\boldsymbol{x}_1, ..., \boldsymbol{x}_N\}\)? Even worse, what if both \(N\), the number of the vectors, as well as their locations \(\boldsymbol{x}_i\) are random? This is not some hypothetical scenario — processes generating such data are abundant in the real world:</p> <ul style="margin-top: 0px"> <li> Transactions generated each day in a financial system</li> <li> Locations of disease outbreaks in a city, recorded each week</li> <li> Times and locations of earthquakes in some geographic region within a year</li> </ul> <p>Point processes provide a framework for modeling and analyzing such data. Each realization of a point process is a set \(\{\boldsymbol{x}_1, \dots, \boldsymbol{x}_N\}\) consisting of a random number \(N\) of <em>points</em> \(\boldsymbol{x}_i\) that live in some space \(\mathcal{X}\), hence the name “point process”. Depending on the choice of the space \(\mathcal{X}\), we distinguish among different types of point processes. For example, \(\mathcal{X} \subseteq \mathbb{R}^D\) corresponds to a so-called <em>spatial point process</em>, where every point \(\boldsymbol{x}_i\) can be viewed as a random location in space (e.g., a location of a disease outbreak).</p> <div class="l-body"> <img class="img-fluid rounded" src="/assets/img/posts/tpp1/spp_sample.png" style="display: block; width: 90%; margin-left: auto; margin-right: auto;"/> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> Two realizations of a spatial point process on $\mathbb{R}^2$. </figcaption> </div> <p>Another important case, to which I will dedicate the rest of this post (and, hopefully, several future ones), are <em>temporal point processes</em> (TPPs), defined on the real half-line \(\mathcal{X} \subseteq [0, \infty)\). We can interpret the points in a TPP as events happening in continuous time, and therefore usually denote them as \(t_i\) (instead of \(\boldsymbol{x}_i\)).</p> <div class="l-body"> <img class="img-fluid rounded" src="/assets/img/posts/tpp1/tpp_sample.png" style="margin-left: auto; margin-right: auto;"/> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> Two realizations of a temporal point process on $[0, T]$. </figcaption> </div> <p>At first it might seem like TPPs are just a (boring) special case of spatial point processes, but this is not true. Because of the ordered structure of the set \([0, \infty)\), we can treat TPP realizations (i.e., sets \(\{t_1, \dots, t_N\}\)) as ordered sequences \(\boldsymbol{t} = (t_1, \dots, t_N)\), where \(t_1 &lt; t_2 &lt; \dots &lt; t_N\). Additionally, we typically assume that the arrival time of the event \(t_i\) is only influenced by the events that happened in the past. As we will see in the next section, this makes specifying TPP distributions rather easy. In contrast, spatial point processes don’t permit such ordering on the events, and because of this often have intractable densities.</p> <p>The theory of temporal point processes was mostly developed near the middle of the 20th century, taking roots in measure theory and stochastic processes. For this reason, the notation and jargon used in TPP literature may sound strange and unfamiliar to people with a machine learning background (at least it did to me back when I started learning about TPPs). In reality, though, most TPP-related concepts can be easily translated into the familiar language of probabilistic machine learning.</p> <p>In this post we will investigate different ways to represent a TPP. As we will see, a TPP can be treated as an autoregressive model or as a counting process. We will learn about the conditional intensity function \(\lambda^*(t)\) — a central concept in the theory of point processes — that unites these two perspectives and allows us to compactly describe various TPP distributions.</p> <h2 id="tpp-as-an-autoregressive-model">TPP as an autoregressive model</h2> <p>How do we define a probabilistic model that generates variable-length event sequences \(\boldsymbol{t} = (t_1, \dots, t_N)\)<d-footnote>Some technicalities: We usually assume that our TPPs are <i>simple</i>. This means that (1) the number of events $N$ is finite almost surely (=with probability one) and (2) the arrival times $t_i$ are distinct, i.e. $t_i \ne t_j$ for all $i\ne j$. Additionally, we assume that $t_i$'s are continuous random variables. This means, among other things, that $\Pr(t_i \in [a, b]) = \Pr(t_i \in (a, b))$, i.e., we shouldn't worry about the interval boundaries too much.</d-footnote> in the interval \([0, T]\)? Thanks to the inherent ordering on the events, we could define our model autoregressively. We start by sampling \(t_1\), the time of the first event, from some probability distribution \(P_1(t_1)\) that is supported on \([0, \infty)\). If \(t_1 &gt; T\), i.e., the event happened outside of the observed interval, we are done — our realization \(\boldsymbol{t}\) is just an empty sequence. Otherwise, we sample the next event \(t_2\) from the conditional distribution \(P_2(t_2 | t_1)\) that is supported on \([t_1, \infty)\). Again, we check if \(t_2 &gt; T\), and if not, proceed to sample \(t_3\) from \(P_3(t_3 | t_1, t_2)\). We repeat this process until some event \(t_{N+1}\) falls outside of the observed interval, at which point we stop the process and get our sample consisting of \(N\) events.</p> <p>At each step we are dealing with the conditional distribution of the event \(t_i\) given the <em>history</em> of the past events \(\mathcal{H}_{t_i} = \{t_j: t_j &lt; t_i\}\). We usually denote this distribution as \(P_i(t_i | \mathcal{H}_{t_i})\). In the literature, you will also often meet the shorthand notation \(P_i^*(t_i)\), where the star reminds us of the dependency on past events. The important question is how to represent the probability distribution \(P_i^*(t_i)\).</p> <p>In machine learning, we usually characterize a continuous probability distribution \(P_i^*\) by specifying its probability density functions (PDF) \(f_i^*\). Loosely speaking, the value \(f_i^*(t) dt\) represents the probability that the event \(t_i\) will happen in the interval \([t, t + dt)\), where \(dt\) is some infinitesimal positive number.<d-footnote>All the explanations involving $dt$ are <a href="https://en.wikipedia.org/wiki/Differential_(infinitesimal)">not 100% rigorous</a> and are used to provide intuition — if we set $dt$ to some tiny positive number, then the equations would be approximately correct. Turning such a handwavy explanation into a rigorous mathematical argument would require taking the limit $dt \to 0$.</d-footnote></p> <p>However, there exist other ways to describe a distribution that might be more useful in certain contexts. For example, the <em>cumulative distribution function</em> (CDF) \(F_i^*(t) = \int_0^{t} f_i^*(u) du\) tells us the probability that the event \(t_i\) will happen before time \(t\). Closely related is the <em>survival function</em> (SF), defined as \(S_i^*(t) = 1 - F_i^*(t)\), which tells us the probability that the event \(t_i\) will happen <em>after</em> time \(t\).</p> <div class="l-body"> <img class="img-fluid rounded" src="/assets/img/posts/tpp1/pdf_cdf_sf.png" style="display: block; width: max(80%, 200px); margin-left: auto; margin-right: auto;"/> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> Interpretation of the PDF, CDF and SF. Here $\mathcal{H}_t = \{t_1, ..., t_{i-1}\}$. </figcaption> </div> <p>Finally, a lesser known option is the <a href="https://en.wikipedia.org/wiki/Failure_rate"><em>hazard function</em></a> \(h_i^*\) that can be computed as \(h^*_i(t) = f_i^*(t) / S_i^*(t)\). The value \(h_i^*(t)dt\) answers the question “What is the probability that the event \(t_i\) will happen in the interval \([t, t + dt)\) given that it didn’t happen before \(t\)?”. Let’s look at this definition more closely to examine the connection between the PDF \(f_i^*\) and the hazard function \(h_i^*\).</p> <p>Consider the following scenario. The most recent event \(t_{i-1}\) has just happened and our clock is at time \(t_{i-1}\). The value \(f_i^*(t)dt\) tells us the probability that the next event \(t_i\) will happen in \([t, t+ dt)\) (see next figure — top). Then, some time has elapsed, our clock is now at time \(t\) and the event \(t_{i}\) hasn’t yet happened. At this point in time, \(f_i^*(t)dt\) is not equal to \(\Pr(t_i \in [t, t + dt) | \mathcal{H}_t)\) anymore — we need to condition on the fact that \(t_i\) didn’t happen before \(t\). For this, we renormalize the PDF such that it integrates to \(1\) over the interval \([t, \infty)\) (see next figure — center).</p> \[f_i^*(t | t_i \ge t) = \frac{f_i^*(t)}{\int_t^\infty f_i^*(u) du} =\frac{f_i^*(t)}{S_i^*(t)} =: h_i^*(t)\] <p>This value of the renormalized PDF exactly corresponds to the hazard function \(h_i^*\) at time \(t\) (see next figure — bottom).</p> <div class="l-body"> <img class="img-fluid rounded" src="/assets/img/posts/tpp1/renorm_pdf.png" style="display: block; width: max(80%, 200px); margin-left: auto; margin-right: auto;"/> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> PDF of $t_i$ (top), PDF of $t_i$ conditioned on $t_i \ge t$ (center), hazard function of $t_i$ (bottom). </figcaption> </div> <p>We can also go in the other direction and compute the PDF \(f_i^*\) using \(h_i^*\). First, we need to compute the survival function</p> \[\begin{aligned} h_i^*(t) &amp;= \frac{f_i^*(t)}{S_i^*(t)} = \frac{- \frac{d}{dt} S_i^*(t)}{S_i^*(t)} = -\frac{d}{dt} \log S_i^*(t)\\ &amp; \Leftrightarrow S_i^*(t) = \exp \left( -\int_{t_{i-1}}^t h_i^*(u) du \right) \end{aligned}\] <p>This, in turn, allows us to obtain the PDF as</p> \[\begin{aligned} f_i^*(t) &amp;= -\frac{d}{dt}S_i^*(t)\\ &amp; = -\frac{d}{dt}\exp \left( -\int_{t_{i-1}}^t h_i^*(u) du \right)\\ &amp;= h_i^*(t) \exp \left( -\int_{t_{i-1}}^t h_i^*(u) du \right) \end{aligned}\] <p>The name “hazard function” comes from the field of <a href="https://en.wikipedia.org/wiki/Survival_analysis">survival analysis</a>, where the goal is to predict hazardous events such as death of a patient or failure of some system. In such a setting, the hazard function \(h_i^*\) is often considered to be more interpretable<d-footnote>In my opinion, only very basic hazard functions are somewhat interpretable --- for example, if the hazard function monotonically increases as $t \to \infty$ (e.g., older people are more likely to die at any given time) or decreases (e.g., if a light bulb didn't break in the first hour of operation, then it's not defect and will serve for a long time). However, if your hazard function is defined by a neural network (e.g., a normalizing flow), I would argue that it's as (un)interpretable as the PDF $f_i^*.$</d-footnote> than the PDF $f_i^*$. For example, if a system hasn’t failed by time \(t_i\), the value \(h_i^*(t)dt\) corresponds to the probability of failure in the immediate future. This quantity can be of interest when planning treatments or allocating resources.</p> <p>Let’s get back to our problem of characterizing the conditional distributions of a TPP. We could specify any of the functions \(f_i^*\), \(F_i^*\), \(S_i^*\) or \(h_i^*\) (subject to the respective constraints<d-footnote>Constraints on PDF, CDF, SF and hazard function are necessary to ensure that they define a valid probability distribution. For example, a PDF $f_i^*$ must satisfy $f_i^*(t) \ge 0$ for all $t$ and $\int_{t_{i-1}}^\infty f_i^*(u) du = 1$. Similarly, a valid hazard function $h_i^*$ must satisfy $h_i^*(t) \ge 0$ for all $t$ and $\int_{t}^{\infty} h_i^*(u) du = \infty$ for all $t$.</d-footnote>), and each one of them would completely describe the distribution \(P_i^*\). Put differently, given one of these functions, we can directly compute the other three. It’s worth noting that there exist other functions (besides the four mentioned above) that we could use to describe a distribution.</p> <div class="l-body"> <img class="img-fluid rounded" src="/assets/img/posts/tpp1/pdf_cdf_sf_hazard.png"/> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> Four ways to represent the conditional distribution $P_i^*(t)$: probability density function $f_i^*$, cumulative distribution function $F_i^*$, survival function $S_i^*$, and hazard function $h_i^*$. </figcaption> </div> <p>In summary, to define the full distribution of some TPP, we could, for instance, specify the conditional PDFs \(\{f_1^*, f_2^*, f_3^*, \dots\}\) or, equivalently, the conditional hazard functions \(\{h_1^*, h_2^*, h_3^*, \dots\}\). However, dealing with all the different conditional distributions and their indices can be unwieldy. Instead, we could consider yet another way of characterizing the TPP — using the <em>conditional intensity function</em>. The conditional intensity, denoted as \(\lambda^*(t)\), is defined by stitching together the conditional hazard functions:</p> \[\lambda^*(t) = \begin{cases} h_1^*(t) &amp; \text{ if } 0 \le t \le t_1 \\ h_2^*(t) &amp; \text{ if } t_1 &lt; t \le t_2 \\ &amp; \vdots\\ h_{N+1}^*(t) &amp; \text{ if } t_N &lt; t \le T \\ \end{cases}\] <p>which can graphically be represented as follows:</p> <div class="l-body"> <img class="img-fluid rounded" src="/assets/img/posts/tpp1/stitching.png" style="display: block; width: max(80%, 200px); margin-left: auto; margin-right: auto;"/> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> The conditional intensity $\lambda^*(t)$ is obtained by stitching together the hazard functions $h_i^*(t)$. </figcaption> </div> <p>Let’s take a step back and remember what the \(*\) notation means here. When we write \(\lambda^*(t)\), we actually mean \(\lambda(t | \mathcal{H}_t)\). That is, the conditional intensity function takes as input two arguments: (1) the current time \(t\) and (2) the set of the preceding events \(\mathcal{H}_t\) that can be of arbitrary size. </p> <p>We can turn the previous statement around: To define a TPP distribution, we simply need to define some non-negative function<d-footnote>The conditional intensity must be non-negative since it's a ratio of two non-negative numbers — the PDF $f_i^*(t)$ and the SF $S_i^*(t)$. There is another technical detail: it should hold for any $t$ and $\mathcal{H}_t$ that $\int_t^{\infty} \lambda(u \vert \mathcal{H}_t) du = \infty$. If the latter condition is not fulfilled, the respective conditional PDF $f_i^*$ won't integrate to 1.</d-footnote> that takes as input the time \(t \in [0, T]\) and a variable-sized set of past events \(\{t_1, \dots, t_{i-1}\}\). This will completely specify the conditional intensity \(\lambda^*(t)\). Given \(\lambda^*(t)\), we can easily recover the conditional hazard functions \(h_i^*\). Finally, we can obtain the conditional PDFs \(f_i^*\) from the \(h_i^*\)’s. Thus, we have completely specified our TPP distribution. Neat!</p> <h2 id="defining-tpps-using-the-conditional-intensity-function">Defining TPPs using the conditional intensity function</h2> <p>The main advantage of the conditional intensity is that it allows to compactly represent various TPPs with different behaviors. For example, we could define a TPP where the intensity is independent of the history and only depends on the time \(t\).</p> \[\lambda^*(t) = g(t)\] <p>This corresponds to the famous <a href="https://en.wikipedia.org/wiki/Poisson_point_process">Poisson process</a>. High values of \(g(t)\) correspond to a higher rate of event occurrence, so the Poisson process allows us to capture global trends. For instance, we could use it to model passenger traffic in a subway network within a day. More events (i.e., ticket purchases) happen in the morning and in the evening compared to the middle of the day, which is reflected by the variations in the intensity \(g(t)\).</p> <div class="l-body"> <img class="img-fluid rounded" src="/assets/img/posts/tpp1/poisson.png" style="display: block; width: max(80%, 200px); margin-left: auto; margin-right: auto;"/> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> A realization of a Poisson process (bottom) and the respective intensity function (top). </figcaption> </div> <p>The Poisson process has a number of other interesting properties and probably deserves a blog post of its own.</p> <p>Another popular example is the <a href="https://arxiv.org/abs/1708.06401">self-exciting process (a.k.a. Hawkes process)</a> with the conditional intensity function</p> \[\lambda^*(t) = \mu + \sum_{t_j \in \mathcal{H}_t} \alpha \exp(-(t - t_j))\] <p>As we see above, the intensity increases by \(\alpha\) whenever an event occurs and then exponentially decays towards the baseline level \(\mu\). Such an intensity function allows us to capture “bursty” event occurrences — events often happen in quick succession. For example, if a neuron fires in the brain, it’s likely that this neuron will fire again in the near future.</p> <div class="l-body"> <img class="img-fluid rounded" src="/assets/img/posts/tpp1/hawkes.png" style="display: block; width: max(80%, 200px); margin-left: auto; margin-right: auto;"/> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> A realization of a Hawkes process (bottom) and the respective intensity function (top). </figcaption> </div> <p>Both of the above examples could equivalently be specified using the conditional PDFs \(f_i^*\) or the hazard functions \(h_i^*\). However, their description in terms of the conditional intensity \(\lambda^*(t)\) is more elegant and compact — we don’t have to worry about the indices \(i\), and we can understand the properties of respective TPPs (such as global trend or burstiness) by simply looking at the definition of \(\lambda^*(t)\).</p> <h2 id="tpp-as-a-counting-process">TPP as a counting process</h2> <p>So far, we have represented TPP realizations as variable-length sequences, but this is not the only possible option. In many textbooks and (especially older) papers a TPP is defined as a <em>counting process</em> <d-footnote>A counting process is a special type of stochastic processes. A <a href="https://en.wikipedia.org/wiki/Stochastic_process">stochastic process</a> is a collection of random variables that are indexed by a real number. In our case, any real number $t \in [0, T]$ corresponds to a random variable $N(t).$</d-footnote> — a probability distribution over functions. Each realization of a counting process is an increasing function \(N \colon [0, T] \to \mathbb{N}_0\). We can think of \(N(t)\) as the number of events that happened before time \(t \in [0, T]\).</p> <p>It’s easy to see that this formulation is equivalent to the one we used before. We can represent an event sequence \(\boldsymbol{t} = (t_1, \dots, t_N)\) as a realization of a counting process by defining</p> \[N(t) = \sum_{i=1}^N \mathbb{I}(t_i \le t)\] <p>where \(\mathbb{I}\) is the indicator function.</p> <div class="l-body"> <img class="img-fluid rounded" src="/assets/img/posts/tpp1/counting.png" style="display: block; width: max(80%, 200px); margin-left: auto; margin-right: auto;"/> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> Realization of a counting process (above) and the respective event sequence (below). </figcaption> </div> <p>Last, we will consider is how to characterize the distribution of a counting process. Not surprisingly, the conditional intensity function \(\lambda^*(t)\) that we defined in the previous section will again come up here.</p> <p>Like before, suppose that \(dt\) is an infinitesimal positive number. We will consider the expected change in \(N(t)\) during \(dt\) given the history of past events \(\mathcal{H}_t\), that is<d-footnote>The first equality follows from the assumption that $dt$ is small enough that at most a single event can happen in the interval $[t, t+ dt)$. Therefore, $N(t + dt) - N(t)$ can take only two values: either 1 or 0. The outcome "$N(t + dt) - N(t) = 1$" can be rephrased as "the event $t_i$ happened in the interval $[t, t+ dt)$ given that it didn't happen in the interval $[t_{i-1}, t)$" (where $t_{i-1}$, without loss of generality, is the last event that happened before time $t$). The probability of this can be computed using the conditional hazard function $h_i^*(t)$, which by definition is equal to the conditional intensity $\lambda^*(t)$.</d-footnote></p> \[\begin{aligned} \mathbb{E}[N(t + dt) - N(t) | \mathcal{H}_t] =&amp; \;1 \cdot \Pr(\text{next event } t_i \text{ happens in } [t, t + dt) | \mathcal{H}_t)\\ &amp;+ 0 \cdot \Pr(\text{no event in } [t, t + dt) | \mathcal{H}_t)\\ =&amp; \Pr(t_i \in [t, t+ dt) | \mathcal{H}_{t})\\ =&amp; h_i^*(t) dt\\ =&amp; \lambda^*(t) dt\\ \end{aligned}\] <p>By rearranging the above equation we could define the conditional intensity function as</p> \[\lambda^*(t) = \lim_{dt \to 0} \frac{\mathbb{E}[N(t + dt) - N(t) | \mathcal{H}_t]}{dt}\] <p>which means, in simple words, that the conditional intensity is the expected number of events in a TPP per unit of time.</p> <h2 id="summary">Summary</h2> <p>We have uncovered the mystery of the name “temporal point process”:</p> <ul> <li><strong>Process</strong> — a TPP can be defined as a counting <em>process</em></li> <li><strong>Point</strong> — we can view each TPP realization $\boldsymbol{t} = (t_1, \dots, t_N)$ as a set of <em>“points”</em></li> <li><strong>Temporal</strong> — we can interpret the “points” $t_i$ as arrival <em>times</em> of events</li> </ul> <p>We learned about different ways to specify a TPP, such as using the conditional intensity \(\lambda^*(t)\) or the conditional PDFs \(\{f_1^*, f_2^*, f_3^*, \dots\}\).</p> <p>In the next post of this series, I will talk about how we can put this theory to practice and implement neural-network-based TPP models.</p> <h3 id="acknowledgments">Acknowledgments</h3> <p>I would like to thank <a href="https://twitter.com/klicperajo">Johannes Klicpera</a> for his feedback on this post.</p> <h3 id="further-reading">Further reading</h3> <ul> <li> <a href="http://learning.mpi-sws.org/tpp-icml18/">ICML 2018 tutorial by Manuel Gomez Rodriguez and Isabel Valera</a></li> <li> <a href="https://arxiv.org/abs/1806.00221">Lecture notes by Jakob Rasmussen</a></li> <li> <a href="https://arxiv.org/abs/1708.06401">A tutorial by Marian-Andrei Rizoiu et al.</a></li> <li> <a href="https://hawkeslib.readthedocs.io/en/latest/tutorial.html">A tutorial on Hawkes processes by Caner Turkmen</a></li> </ul>]]></content><author><name>Oleksandr Shchur</name></author><summary type="html"><![CDATA[How can we define generative models for variable-length event sequences in continuous time?]]></summary></entry></feed>